const PAGES_DIR: &'static str = "src/pages";
const ROUTER_PATH: &'static str = "src/router.rs";

use anyhow::Result;
use qaf_build_utils::PageEntry;
use rust_format::{Formatter, RustFmt};
use std::path::PathBuf;

fn main() -> Result<()> {
    let pages = PathBuf::from(PAGES_DIR);

    let entries: PageEntry = PageEntry::generate(&pages)?;
    let mod_str = entries.get_mods_string()?;
    let routes_str = generate_routes(&entries, &pages);

    let routes = format!(
        r#"
        pub async fn route(mut req: WasmRequest) -> Result<WasmResponse> {{
            let router = WasmRouter::new()
                {};

            let matched = router.routes.get(&req.method).unwrap().at(&req.url)?;
            matched.params.iter().for_each(|(k, v)| {{
                req.params.insert(k.to_string(), v.to_string());
            }});

            let handler = matched.value;
            let resp = handler(req).await;

            return resp;
        }}
        "#,
        routes_str
    );

    let mut main_template_content = format!(
        r#"
            //THIS FILE IS AUTOGENERATED, DO NOT EDIT
            use anyhow::Result;
            use qaf_router::{{WasmRequest, WasmResponse, WasmRouter}};

            #[path = "pages"]
            {}

            {}
        "#,
        mod_str, routes
    );

    main_template_content = RustFmt::new().format_str(main_template_content)?;
    std::fs::write(ROUTER_PATH, main_template_content)?;

    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=qaf.json");
    println!("cargo:rerun-if-changed=src/pages");

    Ok(())
}

pub fn generate_routes(entry: &PageEntry, path: &PathBuf) -> String {
    let mut tmp = String::new();

    for child in &entry.children {
        let mut child_path = path.join(&child.name);
        if child.is_dir {
            tmp += &generate_routes(&child, &child_path);
            continue;
        }

        child_path.set_extension("rs");
        let use_path = path
            .to_str()
            .unwrap()
            .replacen("src/", "", 1)
            .replace(":", "_")
            .replace("/", "::");
        let use_path = format!("{}::{}", use_path, child.name);

        let route_path = path
            .to_str()
            .unwrap()
            .replacen("src/pages", "", 1)
            .to_owned();

        for route in qaf_build_utils::get_file_routes(child_path).unwrap_or(vec![]) {
            let route_path = route_path.clone() + "/" + &route.route.unwrap_or(String::from(""));
            let mut route_path = route_path.trim_end_matches("/");
            if route_path.is_empty() {
                route_path = "/";
            }

            tmp += &format!(
                ".{}(\"{}\", {}::{})",
                route.route_type.to_str(),
                route_path,
                use_path,
                route.function
            );
        }
    }

    return tmp;
}
